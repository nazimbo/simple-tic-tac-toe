<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tic Tac Toe vs AI</title>
    <link type="image/png" sizes="96x96" rel="icon" href="https://img.icons8.com/external-prettycons-flat-prettycons/94/external-tic-tac-toe-games-prettycons-flat-prettycons.png" />
    <style>
      body {
        font-family: "Arial", sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #fff;
      }
      .game-container {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        padding: 20px;
        box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
        backdrop-filter: blur(4px);
        border: 1px solid rgba(255, 255, 255, 0.18);
        transform: translateY(0);
        transition: transform 0.3s ease, box-shadow 0.3s ease;
      }
      .game-container:hover {
        transform: translateY(-5px);
        box-shadow: 0 12px 40px 0 rgba(31, 38, 135, 0.45);
      }
      h1 {
        margin-top: 0;
        font-size: 2.5em;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        background: linear-gradient(45deg, #fff, #f0f0f0);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        animation: titleGlow 2s ease-in-out infinite alternate;
      }
      .board {
        display: grid;
        grid-template-columns: repeat(3, 100px);
        grid-gap: 10px;
        margin: 20px 0;
        perspective: 1000px;
      }
      .cell {
        width: 100px;
        height: 100px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.5);
        border-radius: 10px;
        font-size: 2.5em;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        transform-style: preserve-3d;
        position: relative;
      }
      .cell:hover:not(.disabled) {
        background: rgba(255, 255, 255, 0.2);
        transform: scale(1.05) rotateX(10deg) rotateY(10deg);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      }
      .cell.x, .cell.o {
        animation: placeMark 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }
      .cell.x {
        color: #ff6b6b;
        text-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
      }
      .cell.o {
        color: #4ecdc4;
        text-shadow: 0 0 10px rgba(78, 205, 196, 0.5);
      }
      .cell.winner {
        background: rgba(255, 255, 0, 0.3);
        border-color: yellow;
        animation: winner 1.5s ease infinite;
      }
      .cell.disabled {
        cursor: not-allowed;
        opacity: 0.6;
        transform: scale(1);
      }
      .cell.disabled:hover {
        background: rgba(255, 255, 255, 0.1);
        transform: none;
        box-shadow: none;
      }
      #status {
        font-size: 1.2em;
        margin: 20px 0;
        font-weight: bold;
        min-height: 1.5em;
        text-align: center;
        transition: all 0.3s ease;
      }
      #reset {
        font-size: 1em;
        padding: 12px 24px;
        cursor: pointer;
        background: linear-gradient(45deg, #ff6b6b, #ff8787);
        color: white;
        border: none;
        border-radius: 25px;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        position: relative;
        overflow: hidden;
      }
      #reset:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
      }
      #reset:active {
        transform: translateY(1px);
      }
      #reset::after {
        content: '';
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: rgba(255, 255, 255, 0.2);
        transform: rotate(45deg);
        transition: all 0.3s ease;
        opacity: 0;
      }
      #reset:hover::after {
        opacity: 1;
        transform: rotate(45deg) translate(50%, 50%);
      }
      @keyframes titleGlow {
        0% {
          text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        100% {
          text-shadow: 2px 2px 10px rgba(255, 255, 255, 0.5);
        }
      }
      @keyframes placeMark {
        0% {
          transform: scale(0) rotate(-180deg);
          opacity: 0;
        }
        50% {
          transform: scale(1.2) rotate(0deg);
        }
        100% {
          transform: scale(1) rotate(0deg);
          opacity: 1;
        }
      }
      @keyframes winner {
        0% {
          transform: scale(1);
          box-shadow: 0 0 20px rgba(255, 255, 0, 0.3);
        }
        50% {
          transform: scale(1.05);
          box-shadow: 0 0 30px rgba(255, 255, 0, 0.5);
        }
        100% {
          transform: scale(1);
          box-shadow: 0 0 20px rgba(255, 255, 0, 0.3);
        }
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <h1>Tic Tac Toe vs AI</h1>
      <div id="status">Your turn (X)</div>
      <div class="board" id="board">
        <div class="cell" data-cell-index="0"></div>
        <div class="cell" data-cell-index="1"></div>
        <div class="cell" data-cell-index="2"></div>
        <div class="cell" data-cell-index="3"></div>
        <div class="cell" data-cell-index="4"></div>
        <div class="cell" data-cell-index="5"></div>
        <div class="cell" data-cell-index="6"></div>
        <div class="cell" data-cell-index="7"></div>
        <div class="cell" data-cell-index="8"></div>
      </div>
      <button id="reset">Reset Game</button>
    </div>

    <script>
      // Game state and constants
      const statusDisplay = document.getElementById("status");
      const cells = document.querySelectorAll(".cell");
      const resetButton = document.getElementById("reset");
      const board = document.getElementById("board");

      let gameState = ["", "", "", "", "", "", "", "", ""];
      let gameActive = true;
      let currentPlayer = "X";

      // Winning combinations
      const winningConditions = [
        [0, 1, 2],
        [3, 4, 5],
        [6, 7, 8], // Rows
        [0, 3, 6],
        [1, 4, 7],
        [2, 5, 8], // Columns
        [0, 4, 8],
        [2, 4, 6], // Diagonals
      ];

      // Animation utilities
      const shake = (element) => {
        element.style.animation = "none";
        element.offsetHeight; // Trigger reflow
        element.style.animation = "shake 0.5s cubic-bezier(.36,.07,.19,.97) both";
      };

      const fadeOut = (element, duration = 300) => {
        element.style.opacity = "1";
        element.style.transition = `opacity ${duration}ms ease`;
        element.style.opacity = "0";
        return new Promise(resolve => setTimeout(resolve, duration));
      };

      const fadeIn = (element, duration = 300) => {
        element.style.opacity = "0";
        element.style.transition = `opacity ${duration}ms ease`;
        element.style.opacity = "1";
        return new Promise(resolve => setTimeout(resolve, duration));
      };

      // Enhanced status updates with animations
      const updateStatus = async (message) => {
        await fadeOut(statusDisplay);
        statusDisplay.textContent = message;
        await fadeIn(statusDisplay);
      };

      // Handle cell click event with enhanced animations
      const handleCellClick = async (clickedCellEvent) => {
        const clickedCell = clickedCellEvent.target;
        const clickedCellIndex = parseInt(clickedCell.getAttribute("data-cell-index"));

        // Check if the cell is already filled or game is not active
        if (gameState[clickedCellIndex] !== "" || !gameActive || currentPlayer !== "X") {
          shake(clickedCell);
          return;
        }

        // Update game state and UI with animation
        gameState[clickedCellIndex] = "X";
        clickedCell.textContent = "X";
        clickedCell.classList.add("x");

        // Check for win or draw
        if (checkWin("X")) {
          endGame("X");
          return;
        }
        if (checkDraw()) {
          endGame("draw");
          return;
        }

        // Switch to AI's turn with smooth transition
        currentPlayer = "O";
        await updateStatus("AI is thinking...");
        disableCells();
        setTimeout(makeAIMove, 500);
      };

      // AI move with enhanced animations
      const makeAIMove = async () => {
        if (!gameActive) return;

        let bestScore = -Infinity;
        let bestMove;

        // Find the best move using minimax
        for (let i = 0; i < 9; i++) {
          if (gameState[i] === "") {
            gameState[i] = "O";
            let score = minimax(gameState, 0, false);
            gameState[i] = "";
            if (score > bestScore) {
              bestScore = score;
              bestMove = i;
            }
          }
        }

        // Animate AI's move
        const targetCell = cells[bestMove];
        gameState[bestMove] = "O";
        
        // Add a "thinking" indicator
        targetCell.style.background = "rgba(78, 205, 196, 0.2)";
        await new Promise(resolve => setTimeout(resolve, 300));
        
        targetCell.textContent = "O";
        targetCell.classList.add("o");
        targetCell.style.background = "";

        // Check for win or draw with animations
        if (checkWin("O")) {
          endGame("O");
          return;
        }
        if (checkDraw()) {
          endGame("draw");
          return;
        }

        // Switch back to player's turn with smooth transition
        currentPlayer = "X";
        await updateStatus("Your turn (X)");
        enableCells();
      };

      // Minimax algorithm for AI
      const minimax = (board, depth, isMaximizing) => {
        if (checkWin("O")) return 1;
        if (checkWin("X")) return -1;
        if (checkDraw()) return 0;

        if (isMaximizing) {
          let bestScore = -Infinity;
          for (let i = 0; i < 9; i++) {
            if (board[i] === "") {
              board[i] = "O";
              let score = minimax(board, depth + 1, false);
              board[i] = "";
              bestScore = Math.max(score, bestScore);
            }
          }
          return bestScore;
        } else {
          let bestScore = Infinity;
          for (let i = 0; i < 9; i++) {
            if (board[i] === "") {
              board[i] = "X";
              let score = minimax(board, depth + 1, true);
              board[i] = "";
              bestScore = Math.min(score, bestScore);
            }
          }
          return bestScore;
        }
      };

      // Enhanced win checking with sequential animation
      const checkWin = (player) => {
        return winningConditions.some((condition) => {
          return condition.every((index) => gameState[index] === player);
        });
      };

      // Check for a draw with animation
      const checkDraw = () => !gameState.includes("");

      // Enhanced game end with animations
      const endGame = async (result) => {
        gameActive = false;
        if (result === "draw") {
          await updateStatus("It's a draw!");
          shake(board);
        } else {
          const winningCells = winningConditions.find((condition) => 
            condition.every((index) => gameState[index] === result)
          );
          await highlightWinningCells(winningCells);
          await updateStatus(result === "X" ? "You win!" : "AI wins!");
        }
        disableCells();
      };

      // Enhanced winning cells highlight with sequential animation
      const highlightWinningCells = async (winningCells) => {
        for (const index of winningCells) {
          cells[index].classList.add("winner");
          await new Promise(resolve => setTimeout(resolve, 200));
        }
      };

      // Enhanced cell disable with fade effect
      const disableCells = () => {
        cells.forEach((cell) => {
          if (!cell.classList.contains("winner")) {
            cell.classList.add("disabled");
            cell.style.opacity = "0.6";
          }
        });
      };

      // Enhanced cell enable with fade effect
      const enableCells = () => {
        cells.forEach((cell) => {
          if (cell.textContent === "") {
            cell.classList.remove("disabled");
            cell.style.opacity = "1";
          }
        });
      };

      // Enhanced game reset with animations
      const resetGame = async () => {
        // Fade out the board
        await fadeOut(board);
        
        // Reset game state
        gameState = ["", "", "", "", "", "", "", "", ""];
        gameActive = true;
        currentPlayer = "X";
        
        // Clear cells with animation
        cells.forEach((cell) => {
          cell.textContent = "";
          cell.classList.remove("x", "o", "winner", "disabled");
          cell.style.opacity = "1";
          cell.style.animation = "";
          cell.style.background = "";
        });

        // Fade the board back in
        await fadeIn(board);
        updateStatus("Your turn (X)");
      };

      // Add shake animation to CSS
      const style = document.createElement("style");
      style.textContent = `
        @keyframes shake {
          10%, 90% { transform: translate3d(-1px, 0, 0); }
          20%, 80% { transform: translate3d(2px, 0, 0); }
          30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
          40%, 60% { transform: translate3d(4px, 0, 0); }
        }
      `;
      document.head.appendChild(style);

      // Event listeners
      cells.forEach((cell) => cell.addEventListener("click", handleCellClick));
      resetButton.addEventListener("click", resetGame);
    </script>
  </body>
</html>